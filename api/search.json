[{"id":"53e21df905ab3ba2cdcc4283d49f78aa","title":"vue3","content":"1. Vue3简介\n2020年9月18日，Vue.js发布版3.0版本，代号：One Piece（n\n\n经历了：4800+次提交、40+个RFC、600+次PR、300+贡献者\n\n官方发版地址：Release v3.0.0 One Piece · vuejs&#x2F;core\n\n截止2023年10月，最新的公开版本为：3.3.4\n\n\n1.1. 【性能的提升】\n打包大小减少41%。\n\n初次渲染快55%, 更新渲染快133%。\n\n内存减少54%。\n\n\n1.2.【 源码的升级】\n使用Proxy代替defineProperty实现响应式。\n\n重写虚拟DOM的实现和Tree-Shaking。\n\n\n1.3. 【拥抱TypeScript】\nVue3可以更好的支持TypeScript。\n\n1.4. 【新的特性】\nComposition API（组合API）：\n\nsetup\n\nref与reactive\n\ncomputed与watch\n……\n\n\n\n新的内置组件：\n\nFragment\n\nTeleport\n\nSuspense\n……\n\n\n\n其他改变：\n\n新的生命周期钩子\n\ndata 选项应始终被声明为一个函数\n\n移除keyCode支持作为 v-on 的修饰符\n……\n\n\n\n\n2. 创建Vue3工程2.1. 【基于 vue-cli 创建】点击查看官方文档\n\n\n\n\n\n\n\n\n\n备注：目前vue-cli已处于维护模式，官方推荐基于 Vite 创建项目。\n1234567891011121314151617## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/cli npm install -g @vue/cli## 执行创建命令vue create vue_test##  随后选择3.x##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)##  &gt; 3.x##    2.x## 启动cd vue_testnpm run serve\n\n\n2.2. 【基于 vite 创建】(推荐)vite 是新一代前端构建工具，官网地址：https://vitejs.cn，vite的优势如下：\n\n轻量快速的热重载（HMR），能实现极速的服务启动。\n对 TypeScript、JSX、CSS 等支持开箱即用。\n真正的按需编译，不再等待整个应用编译完成。\nwebpack构建 与 vite构建对比图如下：\t\n\n\n具体操作如下（点击查看官方文档）\n\n12345678910111213141516171819202122## 1.创建命令npm create vue@latest## 2.具体配置## 配置项目名称√ Project name: vue3_test## 是否添加TypeScript支持√ Add TypeScript?  Yes## 是否添加JSX支持√ Add JSX Support?  No## 是否添加路由环境√ Add Vue Router for Single Page Application development?  No## 是否添加pinia环境√ Add Pinia for state management?  No## 是否添加单元测试√ Add Vitest for Unit Testing?  No## 是否添加端到端测试方案√ Add an End-to-End Testing Solution? » No## 是否添加ESLint语法检查√ Add ESLint for code quality?  Yes## 是否添加Prettiert代码格式化√ Add Prettier for code formatting?  No\n自己动手编写一个App组件\n1234567891011121314151617181920&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;h1&gt;你好啊！&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;App&#x27; //组件名  &#125;&lt;/script&gt;&lt;style&gt;  .app &#123;    background-color: #ddd;    box-shadow: 0 0 10px;    border-radius: 10px;    padding: 20px;  &#125;&lt;/style&gt;\n\n安装官方推荐的vscode插件：\n \n\n \n\n总结：\n\nVite 项目中，index.html 是项目的入口文件，在项目最外层。\n加载index.html后，Vite 解析 &lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt; 指向的JavaScript。\nVue3**中是通过 **createApp 函数创建一个应用实例。\n\n2.3. 【一个简单的效果】Vue3向下兼容Vue2语法，且Vue3中的模板中可以没有根标签\n123456789101112131415161718192021222324252627282930313233&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;App&#x27;,    data() &#123;      return &#123;        name:&#x27;张三&#x27;,        age:18,        tel:&#x27;13888888888&#x27;      &#125;    &#125;,    methods:&#123;      changeName()&#123;        this.name = &#x27;zhang-san&#x27;      &#125;,      changeAge()&#123;        this.age += 1      &#125;,      showTel()&#123;        alert(this.tel)      &#125;    &#125;,  &#125;&lt;/script&gt;\n\n\n3. Vue3核心语法3.1.  【OptionsAPI 与 CompositionAPI】\nVue2的API设计是Options（配置）风格的。\nVue3的API设计是Composition（组合）风格的。\n\nOptions API 的弊端Options类型的 API，数据、方法、计算属性等，是分散在：data、methods、computed中的，若想新增或者修改一个需求，就需要分别修改：data、methods、computed，不便于维护和复用。\n\nComposition API 的优势可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。\n\n\n\n\n\n\n\n\n\n\n说明：以上四张动图原创作者：大帅老猿\n3.2. 【拉开序幕的 setup】setup 概述setup是Vue3中一个新的配置项，值是一个函数，它是 Composition API “表演的舞台_”_，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在setup中。\n特点如下：\n\nsetup函数返回的对象中的内容，可直接在模板中使用。\nsetup中访问this是undefined。\nsetup函数会在beforeCreate之前调用，它是“领先”所有钩子执行的。12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;Person&#x27;,    setup()&#123;      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）      let name = &#x27;张三&#x27;      let age = 18      let tel = &#x27;13888888888&#x27;      // 方法，原来写在methods中      function changeName()&#123;        name = &#x27;zhang-san&#x27; //注意：此时这么修改name页面是不变化的        console.log(name)      &#125;      function changeAge()&#123;        age += 1 //注意：此时这么修改age页面是不变化的        console.log(age)      &#125;      function showTel()&#123;        alert(tel)      &#125;      // 返回一个对象，对象中的内容，模板中可以直接使用      return &#123;name,age,tel,changeName,changeAge,showTel&#125;    &#125;  &#125;&lt;/script&gt;\n\nsetup 的返回值\n若返回一个对象：则对象中的：属性、方法等，在模板中均可以直接使用（重点关注）。\n若返回一个函数：则可以自定义渲染内容，代码如下：123setup()&#123;  return ()=&gt; &#x27;你好啊！&#x27;&#125;\n\nsetup 与 Options API 的关系\nVue2 的配置（data、methos……）中可以访问到 setup中的属性、方法。\n但在setup中不能访问到Vue2的配置（data、methos……）。\n如果与Vue2冲突，则setup优先。\n\nsetup 语法糖setup函数有一个语法糖，这个语法糖，可以让我们把setup独立出去，代码如下：\n12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  export default &#123;    name:&#x27;Person&#x27;,  &#125;&lt;/script&gt;&lt;!-- 下面的写法是setup语法糖 --&gt;&lt;script setup lang=&quot;ts&quot;&gt;  console.log(this) //undefined    // 数据（注意：此时的name、age、tel都不是响应式数据）  let name = &#x27;张三&#x27;  let age = 18  let tel = &#x27;13888888888&#x27;  // 方法  function changName()&#123;    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的  &#125;  function changAge()&#123;    console.log(age)    age += 1 //注意：此时这么修改age页面是不变化的  &#125;  function showTel()&#123;    alert(tel)  &#125;&lt;/script&gt;\n扩展：上述代码，还需要编写一个不写setup的script标签，去指定组件名字，比较麻烦，我们可以借助vite中的插件简化\n\n第一步：npm i vite-plugin-vue-setup-extend -D\n\n第二步：vite.config.ts\n123456import &#123; defineConfig &#125; from &#x27;vite&#x27;import VueSetupExtend from &#x27;vite-plugin-vue-setup-extend&#x27;export default defineConfig(&#123;  plugins: [ VueSetupExtend() ]&#125;)\n\n第三步：&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;\n\n\n3.3. 【ref 创建：基本类型的响应式数据】\n作用：定义响应式变量。\n语法：let xxx = ref(初始值)。\n返回值：一个RefImpl的实例对象，简称ref对象或ref，ref对象的value属性是响应式的。\n注意点：\nJS中操作数据需要：xxx.value，但模板中不需要.value，直接使用即可。\n对于let name = ref(&#39;张三&#39;)来说，name不是响应式的，name.value是响应式的。1234567891011121314151617181920212223242526272829303132333435&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;  import &#123;ref&#125; from &#x27;vue&#x27;  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。  let name = ref(&#x27;张三&#x27;)  let age = ref(18)  // tel就是一个普通的字符串，不是响应式的  let tel = &#x27;13888888888&#x27;  function changeName()&#123;    // JS中操作ref对象时候需要.value    name.value = &#x27;李四&#x27;    console.log(name.value)    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。    // name = ref(&#x27;zhang-san&#x27;)  &#125;  function changeAge()&#123;    // JS中操作ref对象时候需要.value    age.value += 1     console.log(age.value)  &#125;  function showTel()&#123;    alert(tel)  &#125;&lt;/script&gt;\n\n\n\n3.4. 【reactive 创建：对象类型的响应式数据】\n作用：定义一个响应式对象（基本类型不要用它，要用ref，否则报错）\n语法：let 响应式对象= reactive(源对象)。\n返回值：一个Proxy的实例对象，简称：响应式对象。\n注意点：reactive定义的响应式数据是“深层次”的。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;    &lt;h2&gt;游戏列表：&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;import &#123; reactive &#125; from &#x27;vue&#x27;// 数据let car = reactive(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)let games = reactive([  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;])let obj = reactive(&#123;  a:&#123;    b:&#123;      c:&#123;        d:666      &#125;    &#125;  &#125;&#125;)function changeCarPrice() &#123;  car.price += 10&#125;function changeFirstGame() &#123;  games[0].name = &#x27;流星蝴蝶剑&#x27;&#125;function test()&#123;  obj.a.b.c.d = 999&#125;&lt;/script&gt;\n\n3.5. 【ref 创建：对象类型的响应式数据】\n其实ref接收的数据可以是：基本类型、对象类型。\n若ref接收的是对象类型，内部其实也是调用了reactive函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;    &lt;h2&gt;游戏列表：&lt;/h2&gt;    &lt;ul&gt;      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;// 数据let car = ref(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)let games = ref([  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;])let obj = ref(&#123;  a:&#123;    b:&#123;      c:&#123;        d:666      &#125;    &#125;  &#125;&#125;)console.log(car)function changeCarPrice() &#123;  car.value.price += 10&#125;function changeFirstGame() &#123;  games.value[0].name = &#x27;流星蝴蝶剑&#x27;&#125;function test()&#123;  obj.value.a.b.c.d = 999&#125;&lt;/script&gt;\n\n3.6. 【ref 对比 reactive】宏观角度看：\n\n\n\n\n\n\n\n\n\n\nref用来定义：基本类型数据、对象类型数据；\n\nreactive用来定义：对象类型数据。\n\n\n\n区别：\n\n\n\n\n\n\n\n\n\n\n\nref创建的变量必须使用.value（可以使用volar插件自动添加.value）。\n \n\nreactive重新分配一个新对象，会失去响应式（可以使用Object.assign去整体替换）。\n\n\n\n使用原则：\n\n\n\n\n\n\n\n\n\n若需要一个基本类型的响应式数据，必须使用ref。\n若需要一个响应式对象，层级不深，ref、reactive都可以。\n若需要一个响应式对象，且层级较深，推荐使用reactive。\n\n\n\n3.7. 【toRefs 与 toRef】\n作用：将一个响应式对象中的每一个属性，转换为ref对象。\n备注：toRefs与toRef功能一致，但toRefs可以批量转换。\n语法如下：12345678910111213141516171819202122232425262728293031323334&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;性别：&#123;&#123;person.gender&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changeGender&quot;&gt;修改性别&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,reactive,toRefs,toRef&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;name:&#x27;张三&#x27;, age:18, gender:&#x27;男&#x27;&#125;)\t  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力  let &#123;name,gender&#125; =  toRefs(person)\t  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力  let age = toRef(person,&#x27;age&#x27;)  // 方法  function changeName()&#123;    name.value += &#x27;~&#x27;  &#125;  function changeAge()&#123;    age.value += 1  &#125;  function changeGender()&#123;    gender.value = &#x27;女&#x27;  &#125;&lt;/script&gt;\n\n3.8. 【computed】作用：根据已有数据计算出新数据（和Vue2中的computed作用一致）。\n  \n\n123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;  import &#123;ref,computed&#125; from &#x27;vue&#x27;  let firstName = ref(&#x27;zhang&#x27;)  let lastName = ref(&#x27;san&#x27;)  // 计算属性——只读取，不修改  /* let fullName = computed(()=&gt;&#123;    return firstName.value + &#x27;-&#x27; + lastName.value  &#125;) */  // 计算属性——既读取又修改  let fullName = computed(&#123;    // 读取    get()&#123;      return firstName.value + &#x27;-&#x27; + lastName.value    &#125;,    // 修改    set(val)&#123;      console.log(&#x27;有人修改了fullName&#x27;,val)      firstName.value = val.split(&#x27;-&#x27;)[0]      lastName.value = val.split(&#x27;-&#x27;)[1]    &#125;  &#125;)  function changeFullName()&#123;    fullName.value = &#x27;li-si&#x27;  &#125; &lt;/script&gt;\n3.9.【watch】\n作用：监视数据的变化（和Vue2中的watch作用一致）\n特点：Vue3中的watch只能监视以下四种数据：\n\n\n\n\n\n\n\n\n\nref定义的数据。\nreactive定义的数据。\n函数返回一个值（getter函数）。\n一个包含上述内容的数组。\n\n\n\n我们在Vue3中使用watch的时候，通常会遇到以下几种情况：\n* 情况一监视ref定义的【基本类型】数据：直接写数据名即可，监视的是其value值的改变。\n123456789101112131415161718192021222324&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况一：监视【ref】定义的【基本类型】数据&lt;/h1&gt;    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,watch&#125; from &#x27;vue&#x27;  // 数据  let sum = ref(0)  // 方法  function changeSum()&#123;    sum.value += 1  &#125;  // 监视，情况一：监视【ref】定义的【基本类型】数据  const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)    if(newValue &gt;= 10)&#123;      stopWatch()    &#125;  &#125;)&lt;/script&gt;\n* 情况二监视ref定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。\n\n\n\n\n\n\n\n\n\n注意：\n\n若修改的是ref定义的对象中的属性，newValue 和 oldValue 都是新值，因为它们是同一个对象。\n\n若修改整个ref定义的对象，newValue 是新值， oldValue 是旧值，因为不是同一个对象了。\n\n\n123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况二：监视【ref】定义的【对象类型】数据&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,watch&#125; from &#x27;vue&#x27;  // 数据  let person = ref(&#123;    name:&#x27;张三&#x27;,    age:18  &#125;)  // 方法  function changeName()&#123;    person.value.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.value.age += 1  &#125;  function changePerson()&#123;    person.value = &#123;name:&#x27;李四&#x27;,age:90&#125;  &#125;  /*     监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视    watch的第一个参数是：被监视的数据    watch的第二个参数是：监视的回调    watch的第三个参数是：配置对象（deep、immediate等等.....）   */  watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person变化了&#x27;,newValue,oldValue)  &#125;,&#123;deep:true&#125;)  &lt;/script&gt;\n*  情况三监视reactive定义的【对象类型】数据，且默认开启了深度监视。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况三：监视【reactive】定义的【对象类型】数据&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;    &lt;hr&gt;    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;test&quot;&gt;修改obj.a.b.c&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;reactive,watch&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;    name:&#x27;张三&#x27;,    age:18  &#125;)  let obj = reactive(&#123;    a:&#123;      b:&#123;        c:666      &#125;    &#125;  &#125;)  // 方法  function changeName()&#123;    person.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.age += 1  &#125;  function changePerson()&#123;    Object.assign(person,&#123;name:&#x27;李四&#x27;,age:80&#125;)  &#125;  function test()&#123;    obj.a.b.c = 888  &#125;  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的  watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person变化了&#x27;,newValue,oldValue)  &#125;)  watch(obj,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;Obj变化了&#x27;,newValue,oldValue)  &#125;)&lt;/script&gt;\n* 情况四监视ref或reactive定义的【对象类型】数据中的某个属性，注意点如下：\n\n若该属性值不是【对象类型】，需要写成函数形式。\n若该属性值是依然是【对象类型】，可直接编，也可写成函数，建议写成函数。\n\n结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;reactive,watch&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;    name:&#x27;张三&#x27;,    age:18,    car:&#123;      c1:&#x27;奔驰&#x27;,      c2:&#x27;宝马&#x27;    &#125;  &#125;)  // 方法  function changeName()&#123;    person.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.age += 1  &#125;  function changeC1()&#123;    person.car.c1 = &#x27;奥迪&#x27;  &#125;  function changeC2()&#123;    person.car.c2 = &#x27;大众&#x27;  &#125;  function changeCar()&#123;    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;  &#125;  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式  /* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)  &#125;) */  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数  watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)  &#125;,&#123;deep:true&#125;)&lt;/script&gt;\n* 情况五监视上述的多个数据\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;情况五：监视上述的多个数据&lt;/h1&gt;    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;reactive,watch&#125; from &#x27;vue&#x27;  // 数据  let person = reactive(&#123;    name:&#x27;张三&#x27;,    age:18,    car:&#123;      c1:&#x27;奔驰&#x27;,      c2:&#x27;宝马&#x27;    &#125;  &#125;)  // 方法  function changeName()&#123;    person.name += &#x27;~&#x27;  &#125;  function changeAge()&#123;    person.age += 1  &#125;  function changeC1()&#123;    person.car.c1 = &#x27;奥迪&#x27;  &#125;  function changeC2()&#123;    person.car.c2 = &#x27;大众&#x27;  &#125;  function changeCar()&#123;    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;  &#125;  // 监视，情况五：监视上述的多个数据  watch([()=&gt;person.name,person.car],(newValue,oldValue)=&gt;&#123;    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)  &#125;,&#123;deep:true&#125;)&lt;/script&gt;\n3.10. 【watchEffect】\n官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。\n\nwatch对比watchEffect\n\n\n\n\n\n\n\n\n\n\n都能监听响应式数据的变化，不同的是监听数据变化的方式不同\n\nwatch：要明确指出监视的数据\n\nwatchEffect：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。\n\n\n\n示例代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1&gt;需求：水温达到50℃，或水位达到20cm，则联系服务器&lt;/h1&gt;    &lt;h2 id=&quot;demo&quot;&gt;水温：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;水位：&#123;&#123;height&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changePrice&quot;&gt;水温+1&lt;/button&gt;    &lt;button @click=&quot;changeSum&quot;&gt;水位+10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,watch,watchEffect&#125; from &#x27;vue&#x27;  // 数据  let temp = ref(0)  let height = ref(0)  // 方法  function changePrice()&#123;    temp.value += 10  &#125;  function changeSum()&#123;    height.value += 1  &#125;  // 用watch实现，需要明确的指出要监视：temp、height  watch([temp,height],(value)=&gt;&#123;    // 从value中获取最新的temp值、height值    const [newTemp,newHeight] = value    // 室温达到50℃，或水位达到20cm，立刻联系服务器    if(newTemp &gt;= 50 || newHeight &gt;= 20)&#123;      console.log(&#x27;联系服务器&#x27;)    &#125;  &#125;)  // 用watchEffect实现，不用  const stopWtach = watchEffect(()=&gt;&#123;    // 室温达到50℃，或水位达到20cm，立刻联系服务器    if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;      console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)      console.log(&#x27;联系服务器&#x27;)    &#125;    // 水温达到100，或水位达到50，取消监视    if(temp.value === 100 || height.value === 50)&#123;      console.log(&#x27;清理了&#x27;)      stopWtach()    &#125;  &#125;)&lt;/script&gt;\n\n3.11. 【标签的 ref 属性】作用：用于注册模板引用。\n\n\n\n\n\n\n\n\n\n\n用在普通DOM标签上，获取的是DOM节点。\n\n用在组件标签上，获取的是组件实例对象。\n\n\n用在普通DOM标签上：\n123456789101112131415161718192021222324252627282930313233&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h1 ref=&quot;title1&quot;&gt;尚硅谷&lt;/h1&gt;    &lt;h2 ref=&quot;title2&quot;&gt;前端&lt;/h2&gt;    &lt;h3 ref=&quot;title3&quot;&gt;Vue&lt;/h3&gt;    &lt;input type=&quot;text&quot; ref=&quot;inpt&quot;&gt; &lt;br&gt;&lt;br&gt;    &lt;button @click=&quot;showLog&quot;&gt;点我打印内容&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref&#125; from &#x27;vue&#x27;\t  let title1 = ref()  let title2 = ref()  let title3 = ref()  function showLog()&#123;    // 通过id获取元素    const t1 = document.getElementById(&#x27;title1&#x27;)    // 打印内容    console.log((t1 as HTMLElement).innerText)    console.log((&lt;HTMLElement&gt;t1).innerText)    console.log(t1?.innerText)    \t\t/************************************/\t\t    // 通过ref获取元素    console.log(title1.value)    console.log(title2.value)    console.log(title3.value)  &#125;&lt;/script&gt;\n\n用在组件标签上：\n123456789101112131415161718192021222324252627282930&lt;!-- 父组件App.vue --&gt;&lt;template&gt;  &lt;Person ref=&quot;ren&quot;/&gt;  &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;  import Person from &#x27;./components/Person.vue&#x27;  import &#123;ref&#125; from &#x27;vue&#x27;  let ren = ref()  function test()&#123;    console.log(ren.value.name)    console.log(ren.value.age)  &#125;&lt;/script&gt;&lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;ref,defineExpose&#125; from &#x27;vue&#x27;\t// 数据  let name = ref(&#x27;张三&#x27;)  let age = ref(18)  /****************************/  /****************************/  // 使用defineExpose将组件中的数据交给外部  defineExpose(&#123;name,age&#125;)&lt;/script&gt;\n\n\n\n3.12. 【props】\n\n\n\n\n\n\n\n\n123456789&gt;// 定义一个接口，限制每个Person对象的格式export interface PersonInter &#123; id:string, name:string,    age:number   &#125;   // 定义一个自定义类型Personsexport type Persons = Array&lt;PersonInter&gt;\n\nApp.vue中代码：\n12345678910111213141516&gt;&lt;template&gt;\t&lt;Person :list=&quot;persons&quot;/&gt;&lt;/template&gt;  &lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;  import Person from &#x27;./components/Person.vue&#x27;  import &#123;reactive&#125; from &#x27;vue&#x27;    import &#123;type Persons&#125; from &#x27;./types&#x27;      let persons = reactive&lt;Persons&gt;([     &#123;id:&#x27;e98219e12&#x27;,name:&#x27;张三&#x27;,age:18&#125;,      &#123;id:&#x27;e98219e13&#x27;,name:&#x27;李四&#x27;,age:19&#125;,       &#123;id:&#x27;e98219e14&#x27;,name:&#x27;王五&#x27;,age:20&#125;     ])   &lt;/script&gt;  \n\nPerson.vue中代码：\n1234567891011121314151617181920212223242526&gt;&lt;template&gt;&lt;div class=&quot;person&quot;&gt; &lt;ul&gt;     &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;        &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;   &lt;/div&gt;   &lt;/template&gt;  &lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;import &#123;defineProps&#125; from &#x27;vue&#x27;import &#123;type PersonInter&#125; from &#x27;@/types&#x27;    // 第一种写法：仅接收// const props = defineProps([&#x27;list&#x27;])    // 第二种写法：接收+限制类型// defineProps&lt;&#123;list:Persons&#125;&gt;()    // 第三种写法：接收+限制类型+指定默认值+限制必要性let props = withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;     list:()=&gt;[&#123;id:&#x27;asdasg01&#x27;,name:&#x27;小猪佩奇&#x27;,age:18&#125;]  &#125;)   console.log(props)  &lt;/script&gt;\n\n3.13. 【生命周期】\n概念：Vue组件实例在创建时要经历一系列的初始化步骤，在此过程中Vue会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子\n\n规律：\n\n\n\n\n\n\n\n\n\n生命周期整体分为四个阶段，分别是：创建、挂载、更新、销毁，每个阶段都有两个钩子，一前一后。\n\nVue2的生命周期\n\n\n\n\n\n\n\n\n\n创建阶段：beforeCreate、created\n挂载阶段：beforeMount、mounted\n更新阶段：beforeUpdate、updated\n销毁阶段：beforeDestroy、destroyed\n\nVue3的生命周期\n\n\n\n\n\n\n\n\n\n创建阶段：setup\n挂载阶段：onBeforeMount、onMounted\n更新阶段：onBeforeUpdate、onUpdated\n卸载阶段：onBeforeUnmount、onUnmounted\n\n常用的钩子：onMounted(挂载完毕)、onUpdated(更新完毕)、onBeforeUnmount(卸载之前)\n\n示例代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!-- vue3写法 --&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;  import &#123;     ref,     onBeforeMount,     onMounted,     onBeforeUpdate,     onUpdated,     onBeforeUnmount,     onUnmounted   &#125; from &#x27;vue&#x27;  // 数据  let sum = ref(0)  // 方法  function changeSum() &#123;    sum.value += 1  &#125;  console.log(&#x27;setup&#x27;)  // 生命周期钩子  onBeforeMount(()=&gt;&#123;    console.log(&#x27;挂载之前&#x27;)  &#125;)  onMounted(()=&gt;&#123;    console.log(&#x27;挂载完毕&#x27;)  &#125;)  onBeforeUpdate(()=&gt;&#123;    console.log(&#x27;更新之前&#x27;)  &#125;)  onUpdated(()=&gt;&#123;    console.log(&#x27;更新完毕&#x27;)  &#125;)  onBeforeUnmount(()=&gt;&#123;    console.log(&#x27;卸载之前&#x27;)  &#125;)  onUnmounted(()=&gt;&#123;    console.log(&#x27;卸载完毕&#x27;)  &#125;)&lt;/script&gt;\n\n3.14. 【自定义hook】\n什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装，类似于vue2.x中的mixin。\n\n自定义hook的优势：复用代码, 让setup中的逻辑更清楚易懂。\n\n\n示例代码：\n\nuseSum.ts中内容如下：\n123456789101112131415161718import &#123;ref,onMounted&#125; from &#x27;vue&#x27;export default function()&#123;  let sum = ref(0)  const increment = ()=&gt;&#123;    sum.value += 1  &#125;  const decrement = ()=&gt;&#123;    sum.value -= 1  &#125;  onMounted(()=&gt;&#123;    increment()  &#125;)  //向外部暴露数据  return &#123;sum,increment,decrement&#125;&#125;\t\t\n\nuseDog.ts中内容如下：\n12345678910111213141516171819202122232425262728import &#123;reactive,onMounted&#125; from &#x27;vue&#x27;import axios,&#123;AxiosError&#125; from &#x27;axios&#x27;export default function()&#123;  let dogList = reactive&lt;string[]&gt;([])  // 方法  async function getDog()&#123;    try &#123;      // 发请求      let &#123;data&#125; = await axios.get(&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;)      // 维护数据      dogList.push(data.message)    &#125; catch (error) &#123;      // 处理错误      const err = &lt;AxiosError&gt;error      console.log(err.message)    &#125;  &#125;  // 挂载钩子  onMounted(()=&gt;&#123;    getDog()  &#125;)\t  //向外部暴露数据  return &#123;dogList,getDog&#125;&#125;\n\n组件中具体使用：\n12345678910111213141516171819202122232425&lt;template&gt;  &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;  &lt;button @click=&quot;increment&quot;&gt;点我+1&lt;/button&gt;  &lt;button @click=&quot;decrement&quot;&gt;点我-1&lt;/button&gt;  &lt;hr&gt;  &lt;img v-for=&quot;(u,index) in dogList.urlList&quot; :key=&quot;index&quot; :src=&quot;(u as string)&quot;&gt;   &lt;span v-show=&quot;dogList.isLoading&quot;&gt;加载中......&lt;/span&gt;&lt;br&gt;  &lt;button @click=&quot;getDog&quot;&gt;再来一只狗&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123;defineComponent&#125; from &#x27;vue&#x27;  export default defineComponent(&#123;    name:&#x27;App&#x27;,  &#125;)&lt;/script&gt;&lt;script setup lang=&quot;ts&quot;&gt;  import useSum from &#x27;./hooks/useSum&#x27;  import useDog from &#x27;./hooks/useDog&#x27;\t  let &#123;sum,increment,decrement&#125; = useSum()  let &#123;dogList,getDog&#125; = useDog()&lt;/script&gt;\n\n\n4. 路由4.1. 【对路由的理解】 \n\n4.2. 【基本切换效果】\nVue3中要使用vue-router的最新版本，目前是4版本。\n\n路由配置文件代码如下：\n12345678910111213141516171819import &#123;createRouter,createWebHistory&#125; from &#x27;vue-router&#x27;import Home from &#x27;@/pages/Home.vue&#x27;import News from &#x27;@/pages/News.vue&#x27;import About from &#x27;@/pages/About.vue&#x27;const router = createRouter(&#123;\thistory:createWebHistory(),\troutes:[\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;\t]&#125;)export default router\n\n\nmain.ts代码如下：\n1234import router from &#x27;./router/index&#x27;app.use(router)app.mount(&#x27;#app&#x27;)\n\n\nApp.vue代码如下\n12345678910111213141516171819&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;h2 class=&quot;title&quot;&gt;Vue路由测试&lt;/h2&gt;    &lt;!-- 导航区 --&gt;    &lt;div class=&quot;navigate&quot;&gt;      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt;      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt;    &lt;/div&gt;    &lt;!-- 展示区 --&gt;    &lt;div class=&quot;main-content&quot;&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;  import &#123;RouterLink,RouterView&#125; from &#x27;vue-router&#x27;  &lt;/script&gt;\n\n4.3. 【两个注意点】\n\n\n\n\n\n\n\n\n\n路由组件通常存放在pages 或 views文件夹，一般组件通常存放在components文件夹。\n\n通过点击导航，视觉效果上“消失” 了的路由组件，默认是被卸载掉的，需要的时候再去挂载。\n\n\n4.4.【路由器工作模式】\nhistory模式\n\n\n\n\n\n\n\n\n\n优点：URL更加美观，不带有#，更接近传统的网站URL。\n缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有404错误。\n1234const router = createRouter(&#123;  \thistory:createWebHistory(), //history模式  \t/******/&#125;)\n\nhash模式\n\n\n\n\n\n\n\n\n\n优点：兼容性更好，因为不需要服务器端处理路径。\n缺点：URL带有#不太美观，且在SEO优化方面相对较差。\n1234const router = createRouter(&#123;  \thistory:createWebHashHistory(), //hash模式  \t/******/&#125;)\n\n\n4.5. 【to的两种写法】12345&lt;!-- 第一种：to的字符串写法 --&gt;&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;&lt;!-- 第二种：to的对象写法 --&gt;&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;\n\n4.6. 【命名路由】作用：可以简化路由跳转及传参（后面就讲）。\n给路由规则命名：\n1234567891011121314151617routes:[  &#123;    name:&#x27;zhuye&#x27;,    path:&#x27;/home&#x27;,    component:Home  &#125;,  &#123;    name:&#x27;xinwen&#x27;,    path:&#x27;/news&#x27;,    component:News,  &#125;,  &#123;    name:&#x27;guanyu&#x27;,    path:&#x27;/about&#x27;,    component:About  &#125;]\n\n跳转路由：\n12345&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;&lt;router-link to=&quot;/news/detail&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n\n\n4.7. 【嵌套路由】\n编写News的子路由：Detail.vue\n\n配置路由规则，使用children配置项：\n12345678910111213141516171819202122232425262728const router = createRouter(&#123;  history:createWebHistory(),\troutes:[\t\t&#123;\t\t\tname:&#x27;zhuye&#x27;,\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;,\t\t&#123;\t\t\tname:&#x27;xinwen&#x27;,\t\t\tpath:&#x27;/news&#x27;,\t\t\tcomponent:News,\t\t\tchildren:[\t\t\t\t&#123;\t\t\t\t\tname:&#x27;xiang&#x27;,\t\t\t\t\tpath:&#x27;detail&#x27;,\t\t\t\t\tcomponent:Detail\t\t\t\t&#125;\t\t\t]\t\t&#125;,\t\t&#123;\t\t\tname:&#x27;guanyu&#x27;,\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;\t]&#125;)export default router\n\n跳转路由（记得要加完整路径）：\n123&lt;router-link to=&quot;/news/detail&quot;&gt;xxxx&lt;/router-link&gt;&lt;!-- 或 --&gt;&lt;router-link :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;xxxx&lt;/router-link&gt;\n\n记得去Home组件中预留一个&lt;router-view&gt;\n123456789101112&lt;template&gt;  &lt;div class=&quot;news&quot;&gt;    &lt;nav class=&quot;news-list&quot;&gt;      &lt;RouterLink v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot; :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;        &#123;&#123;news.name&#125;&#125;      &lt;/RouterLink&gt;    &lt;/nav&gt;    &lt;div class=&quot;news-detail&quot;&gt;      &lt;RouterView/&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\n4.8. 【路由传参】query参数\n传递参数\n12345678910111213141516171819&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;\t跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;&lt;RouterLink   :to=&quot;&#123;    //name:&#x27;xiang&#x27;, //用name也可以跳转    path:&#x27;/news/detail&#x27;,    query:&#123;      id:news.id,      title:news.title,      content:news.content    &#125;  &#125;&quot;&gt;  &#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;\n\n接收参数：\n1234import &#123;useRoute&#125; from &#x27;vue-router&#x27;const route = useRoute()// 打印query参数console.log(route.query)\n\nparams参数\n传递参数\n12345678910111213141516&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;\t\t\t\t&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;&lt;RouterLink   :to=&quot;&#123;    name:&#x27;xiang&#x27;, //用name跳转    params:&#123;      id:news.id,      title:news.title,      content:news.title    &#125;  &#125;&quot;&gt;  &#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;\n\n接收参数：\n1234import &#123;useRoute&#125; from &#x27;vue-router&#x27;const route = useRoute()// 打印params参数console.log(route.params)\n\n\n备注1：传递params参数时，若使用to的对象写法，必须使用name配置项，不能用path。\n备注2：传递params参数时，需要提前在规则中占位。\n4.9. 【路由的props配置】作用：让路由组件更方便的收到参数（可以将路由参数作为props传给组件）\n12345678910111213141516&#123;\tname:&#x27;xiang&#x27;,\tpath:&#x27;detail/:id/:title/:content&#x27;,\tcomponent:Detail,  // props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件  // props:&#123;a:1,b:2,c:3&#125;,   // props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件  // props:true    // props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件  props(route)&#123;    return route.query  &#125;&#125;\n\n4.10. 【 replace属性】\n作用：控制路由跳转时操作浏览器历史记录的模式。\n\n浏览器的历史记录有两种写入方式：分别为push和replace：\n\npush是追加历史记录（默认值）。\nreplace是替换当前记录。\n\n\n开启replace模式：\n1&lt;RouterLink replace .......&gt;News&lt;/RouterLink&gt;\n\n4.11. 【编程式导航】路由组件的两个重要的属性：$route和$router变成了两个hooks\n123456789import &#123;useRoute,useRouter&#125; from &#x27;vue-router&#x27;const route = useRoute()const router = useRouter()console.log(route.query)console.log(route.parmas)console.log(router.push)console.log(router.replace)\n\n4.12. 【重定向】\n作用：将特定的路径，重新定向到已有路由。\n\n具体编码：\n1234&#123;    path:&#x27;/&#x27;,    redirect:&#x27;/about&#x27;&#125;\n\n5. pinia5.1【准备一个效果】 \n\n5.2【搭建 pinia 环境】第一步：npm install pinia\n第二步：操作src/main.ts\n12345678910111213import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;/* 引入createPinia，用于创建pinia */import &#123; createPinia &#125; from &#x27;pinia&#x27;/* 创建pinia */const pinia = createPinia()const app = createApp(App)/* 使用插件 */&#123;&#125;app.use(pinia)app.mount(&#x27;#app&#x27;)\n\n此时开发者工具中已经有了pinia选项\n\n\n5.3【存储+读取数据】\nStore是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它。\n\n它有三个概念：state、getter、action，相当于组件中的： data、 computed 和 methods。\n\n具体编码：src/store/count.ts\n12345678910111213141516// 引入defineStore用于创建storeimport &#123;defineStore&#125; from &#x27;pinia&#x27;// 定义并暴露一个storeexport const useCountStore = defineStore(&#x27;count&#x27;,&#123;  // 动作  actions:&#123;&#125;,  // 状态  state()&#123;    return &#123;      sum:6    &#125;  &#125;,  // 计算  getters:&#123;&#125;&#125;)\n\n具体编码：src/store/talk.ts\n1234567891011121314151617181920// 引入defineStore用于创建storeimport &#123;defineStore&#125; from &#x27;pinia&#x27;// 定义并暴露一个storeexport const useTalkStore = defineStore(&#x27;talk&#x27;,&#123;  // 动作  actions:&#123;&#125;,  // 状态  state()&#123;    return &#123;      talkList:[        &#123;id:&#x27;yuysada01&#x27;,content:&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;&#125;,     \t\t&#123;id:&#x27;yuysada02&#x27;,content:&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;&#125;,        &#123;id:&#x27;yuysada03&#x27;,content:&#x27;心里给你留了一块地，我的死心塌地&#x27;&#125;      ]    &#125;  &#125;,  // 计算  getters:&#123;&#125;&#125;)\n\n组件中使用state中的数据\n1234567891011&lt;template&gt;  &lt;h2&gt;当前求和为：&#123;&#123; sumStore.sum &#125;&#125;&lt;/h2&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;  // 引入对应的useXxxxxStore\t  import &#123;useSumStore&#125; from &#x27;@/store/sum&#x27;    // 调用useXxxxxStore得到对应的store  const sumStore = useSumStore()&lt;/script&gt;\n\n1234567891011121314&lt;template&gt;\t&lt;ul&gt;    &lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&gt;      &#123;&#123; talk.content &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;  import axios from &#x27;axios&#x27;  import &#123;useTalkStore&#125; from &#x27;@/store/talk&#x27;  const talkStore = useTalkStore()&lt;/script&gt;\n\n5.4.【修改数据】(三种方式)\n第一种修改方式，直接修改\n1countStore.sum = 666\n\n第二种修改方式：批量修改\n1234countStore.$patch(&#123;  sum:999,  school:&#x27;atguigu&#x27;&#125;)\n\n第三种修改方式：借助action修改（action中可以编写一些业务逻辑）\n123456789101112131415161718192021import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;  /*************/  actions: &#123;    //加    increment(value:number) &#123;      if (this.sum &lt; 10) &#123;        //操作countStore中的sum        this.sum += value      &#125;    &#125;,    //减    decrement(value:number)&#123;      if(this.sum &gt; 1)&#123;        this.sum -= value      &#125;    &#125;  &#125;,  /*************/&#125;)\n\n组件中调用action即可\n12345// 使用countStoreconst countStore = useCountStore()// 调用对应actioncountStore.incrementOdd(n.value)\n\n5.5.【storeToRefs】\n借助storeToRefs将store中的数据转为ref对象，方便在模板中使用。\n注意：pinia提供的storeToRefs只会将数据做转换，而Vue的toRefs会转换store中数据。\n\n1234567891011121314151617&lt;template&gt;\t&lt;div class=&quot;count&quot;&gt;\t\t&lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;  import &#123; useCountStore &#125; from &#x27;@/store/count&#x27;  /* 引入storeToRefs */  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;\t/* 得到countStore */  const countStore = useCountStore()  /* 使用storeToRefs转换countStore，随后解构 */  const &#123;sum&#125; = storeToRefs(countStore)&lt;/script&gt;\n\n5.6.【getters】\n概念：当state中的数据，需要经过处理后再使用时，可以使用getters配置。\n\n追加getters配置。\n123456789101112131415161718192021222324// 引入defineStore用于创建storeimport &#123;defineStore&#125; from &#x27;pinia&#x27;// 定义并暴露一个storeexport const useCountStore = defineStore(&#x27;count&#x27;,&#123;  // 动作  actions:&#123;    /************/  &#125;,  // 状态  state()&#123;    return &#123;      sum:1,      school:&#x27;atguigu&#x27;    &#125;  &#125;,  // 计算  getters:&#123;    bigSum:(state):number =&gt; state.sum *10,    upperSchool():string&#123;      return this. school.toUpperCase()    &#125;  &#125;&#125;)\n\n组件中读取数据：\n12const &#123;increment,decrement&#125; = countStorelet &#123;sum,school,bigSum,upperSchool&#125; = storeToRefs(countStore)\n\n5.7.【$subscribe】通过 store 的 $subscribe() 方法侦听 state 及其变化\n1234talkStore.$subscribe((mutate,state)=&gt;&#123;  console.log(&#x27;LoveTalk&#x27;,mutate,state)  localStorage.setItem(&#x27;talk&#x27;,JSON.stringify(talkList.value))&#125;)\n\n\n\n5.8. 【store组合式写法】12345678910111213141516171819202122import &#123;defineStore&#125; from &#x27;pinia&#x27;import axios from &#x27;axios&#x27;import &#123;nanoid&#125; from &#x27;nanoid&#x27;import &#123;reactive&#125; from &#x27;vue&#x27;export const useTalkStore = defineStore(&#x27;talk&#x27;,()=&gt;&#123;  // talkList就是state  const talkList = reactive(    JSON.parse(localStorage.getItem(&#x27;talkList&#x27;) as string) || []  )  // getATalk函数相当于action  async function getATalk()&#123;    // 发请求，下面这行的写法是：连续解构赋值+重命名    let &#123;data:&#123;content:title&#125;&#125; = await axios.get(&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;)    // 把请求回来的字符串，包装成一个对象    let obj = &#123;id:nanoid(),title&#125;    // 放到数组中    talkList.unshift(obj)  &#125;  return &#123;talkList,getATalk&#125;&#125;)\n\n\n\n6. 组件通信Vue3组件通信和Vue2的区别：\n\n移出事件总线，使用mitt代替。\n\n\nvuex换成了pinia。\n把.sync优化到了v-model里面了。\n把$listeners所有的东西，合并到$attrs中了。\n$children被砍掉了。\n\n常见搭配形式：\n \n\n6.1. 【props】概述：props是使用频率最高的一种通信方式，常用与 ：父 ↔ 子。\n\n若 父传子：属性值是非函数。\n若 子传父：属性值是函数。\n\n父组件：\n1234567891011121314151617181920&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件，&lt;/h3&gt;\t\t&lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;\t\t&lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;\timport Child from &#x27;./Child.vue&#x27;\timport &#123; ref &#125; from &quot;vue&quot;;\t// 数据\tconst car = ref(&#x27;奔驰&#x27;)\tconst toy = ref()\t// 方法\tfunction getToy(value:string)&#123;\t\ttoy.value = value\t&#125;&lt;/script&gt;\n\n子组件\n123456789101112131415&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h3&gt;子组件&lt;/h3&gt;\t\t&lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;\t\t&lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;\timport &#123; ref &#125; from &quot;vue&quot;;\tconst toy = ref(&#x27;奥特曼&#x27;)\t\tdefineProps([&#x27;car&#x27;,&#x27;getToy&#x27;])&lt;/script&gt;\n\n6.2. 【自定义事件】\n概述：自定义事件常用于：子 &#x3D;&gt; 父。\n注意区分好：原生事件、自定义事件。\n\n\n原生事件：\n事件名是特定的（click、mosueenter等等）\t\n事件对象$event: 是包含事件相关信息的对象（pageX、pageY、target、keyCode）\n\n\n自定义事件：\n事件名是任意名称\n事件对象$event: 是调用emit时所提供的数据，可以是任意类型！！！\n\n\n\n\n示例：\n12345&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;&lt;Child @send-toy=&quot;toy = $event&quot;/&gt;&lt;!--注意区分原生事件与自定义事件中的$event--&gt;&lt;button @click=&quot;toy = $event&quot;&gt;测试&lt;/button&gt;\n\n12//子组件中，触发事件：this.$emit(&#x27;send-toy&#x27;, 具体数据)\n\n6.3. 【mitt】概述：与消息订阅与发布（pubsub）功能类似，可以实现任意组件间通信。\n安装mitt\n1npm i mitt\n\n新建文件：src\\utils\\emitter.ts\n1234567891011121314151617181920212223242526272829// 引入mitt import mitt from &quot;mitt&quot;;// 创建emitterconst emitter = mitt()/*  // 绑定事件  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;    console.log(&#x27;abc事件被触发&#x27;,value)  &#125;)  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;    console.log(&#x27;xyz事件被触发&#x27;,value)  &#125;)  setInterval(() =&gt; &#123;    // 触发事件    emitter.emit(&#x27;abc&#x27;,666)    emitter.emit(&#x27;xyz&#x27;,777)  &#125;, 1000);  setTimeout(() =&gt; &#123;    // 清理事件    emitter.all.clear()  &#125;, 3000); */// 创建并暴露mittexport default emitter\n\n接收数据的组件中：绑定事件、同时在销毁前解绑事件：\n123456789101112import emitter from &quot;@/utils/emitter&quot;;import &#123; onUnmounted &#125; from &quot;vue&quot;;// 绑定事件emitter.on(&#x27;send-toy&#x27;,(value)=&gt;&#123;  console.log(&#x27;send-toy事件被触发&#x27;,value)&#125;)onUnmounted(()=&gt;&#123;  // 解绑事件  emitter.off(&#x27;send-toy&#x27;)&#125;)\n\n【第三步】：提供数据的组件，在合适的时候触发事件\n123456import emitter from &quot;@/utils/emitter&quot;;function sendToy()&#123;  // 触发事件  emitter.emit(&#x27;send-toy&#x27;,toy.value)&#125;\n\n注意这个重要的内置关系，总线依赖着这个内置关系\n6.4.【v-model】\n概述：实现 父↔子 之间相互通信。\n\n前序知识 —— v-model的本质\n123456789&lt;!-- 使用v-model指令 --&gt;&lt;input type=&quot;text&quot; v-model=&quot;userName&quot;&gt;&lt;!-- v-model的本质是下面这行代码 --&gt;&lt;input   type=&quot;text&quot;   :value=&quot;userName&quot;   @input=&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;&gt;\n\n组件标签上的v-model的本质：:moldeValue ＋ update:modelValue事件。\n12345&lt;!-- 组件标签上使用v-model指令 --&gt;&lt;AtguiguInput v-model=&quot;userName&quot;/&gt;&lt;!-- 组件标签上v-model的本质 --&gt;&lt;AtguiguInput :modelValue=&quot;userName&quot; @update:model-value=&quot;userName = $event&quot;/&gt;\n\nAtguiguInput组件中：\n123456789101112131415161718&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;\t\t&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;    &lt;input        type=&quot;text&quot;        :value=&quot;modelValue&quot;        @input=&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;    &gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;  // 接收props  defineProps([&#x27;modelValue&#x27;])  // 声明事件  const emit = defineEmits([&#x27;update:model-value&#x27;])&lt;/script&gt;\n\n也可以更换value，例如改成abc\n12345&lt;!-- 也可以更换value，例如改成abc--&gt;&lt;AtguiguInput v-model:abc=&quot;userName&quot;/&gt;&lt;!-- 上面代码的本质如下 --&gt;&lt;AtguiguInput :abc=&quot;userName&quot; @update:abc=&quot;userName = $event&quot;/&gt;\n\nAtguiguInput组件中：\n12345678910111213141516&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;input        type=&quot;text&quot;        :value=&quot;abc&quot;        @input=&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;    &gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;  // 接收props  defineProps([&#x27;abc&#x27;])  // 声明事件  const emit = defineEmits([&#x27;update:abc&#x27;])&lt;/script&gt;\n\n如果value可以更换，那么就可以在组件标签上多次使用v-model\n1&lt;AtguiguInput v-model:abc=&quot;userName&quot; v-model:xyz=&quot;password&quot;/&gt;\n\n6.5.【$attrs 】\n概述：$attrs用于实现当前组件的父组件，向当前组件的子组件通信（祖→孙）。\n\n具体说明：$attrs是一个对象，包含所有父组件传入的标签属性。\n\n\n\n\n\n\n\n\n\n 注意：$attrs会自动排除props中声明的属性(可以认为声明过的 props 被子组件自己“消费”了)\n\n\n父组件：\n12345678910111213141516171819&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件&lt;/h3&gt;\t\t&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot; :updateA=&quot;updateA&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;\timport Child from &#x27;./Child.vue&#x27;\timport &#123; ref &#125; from &quot;vue&quot;;\tlet a = ref(1)\tlet b = ref(2)\tlet c = ref(3)\tlet d = ref(4)\tfunction updateA(value)&#123;\t\ta.value = value\t&#125;&lt;/script&gt;\n\n子组件：\n12345678910&lt;template&gt;\t&lt;div class=&quot;child&quot;&gt;\t\t&lt;h3&gt;子组件&lt;/h3&gt;\t\t&lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;\timport GrandChild from &#x27;./GrandChild.vue&#x27;&lt;/script&gt;\n\n孙组件：\n12345678910111213141516&lt;template&gt;\t&lt;div class=&quot;grand-child&quot;&gt;\t\t&lt;h3&gt;孙组件&lt;/h3&gt;\t\t&lt;h4&gt;a：&#123;&#123; a &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;b：&#123;&#123; b &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;c：&#123;&#123; c &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;d：&#123;&#123; d &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;x：&#123;&#123; x &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;y：&#123;&#123; y &#125;&#125;&lt;/h4&gt;\t\t&lt;button @click=&quot;updateA(666)&quot;&gt;点我更新A&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;\tdefineProps([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;updateA&#x27;])&lt;/script&gt;\n\n6.6. 【$refs、$parent】\n概述：\n\n$refs用于 ：父→子。\n$parent用于：子→父。\n\n\n原理如下：\n\n\n\n属性\n说明\n\n\n\n$refs\n值为对象，包含所有被ref属性标识的DOM元素或组件实例。\n\n\n$parent\n值为对象，当前组件的父组件实例对象。\n\n\n\n\n6.7. 【provide、inject】\n概述：实现祖孙组件直接通信\n\n具体使用：\n\n在祖先组件中通过provide配置向后代组件提供数据\n在后代组件中通过inject配置来声明接收数据\n\n\n具体编码：\n【第一步】父组件中，使用provide提供数据\n12345678910111213141516171819202122232425262728&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件&lt;/h3&gt;    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;    &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt;    &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt;    &lt;Child/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;  import Child from &#x27;./Child.vue&#x27;  import &#123; ref,reactive,provide &#125; from &quot;vue&quot;;  // 数据  let money = ref(100)  let car = reactive(&#123;    brand:&#x27;奔驰&#x27;,    price:100  &#125;)  // 用于更新money的方法  function updateMoney(value:number)&#123;    money.value += value  &#125;  // 提供数据  provide(&#x27;moneyContext&#x27;,&#123;money,updateMoney&#125;)  provide(&#x27;car&#x27;,car)&lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\n注意：子组件中不用编写任何东西，是不受到任何打扰的\n【第二步】孙组件中使用inject配置项接受数据。\n123456789101112131415   &lt;template&gt;     &lt;div class=&quot;grand-child&quot;&gt;       &lt;h3&gt;我是孙组件&lt;/h3&gt;       &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;       &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;       &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt;     &lt;/div&gt;   &lt;/template&gt;      &lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;     import &#123; inject &#125; from &#x27;vue&#x27;;     // 注入数据    let &#123;money,updateMoney&#125; = inject(&#x27;moneyContext&#x27;,&#123;money:0,updateMoney:(x:number)=&gt;&#123;&#125;&#125;)     let car = inject(&#x27;car&#x27;)&lt;/script&gt;\n\n6.8. 【pinia】参考之前pinia部分的讲解\n6.9. 【slot】1. 默认插槽\n1234567891011121314父组件中：        &lt;Category title=&quot;今日热门游戏&quot;&gt;          &lt;ul&gt;            &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;          &lt;/ul&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;          &lt;div class=&quot;item&quot;&gt;            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;            &lt;!-- 默认插槽 --&gt;            &lt;slot&gt;&lt;/slot&gt;          &lt;/div&gt;        &lt;/template&gt;\n\n2. 具名插槽12345678910111213141516171819父组件中：        &lt;Category title=&quot;今日热门游戏&quot;&gt;          &lt;template v-slot:s1&gt;            &lt;ul&gt;              &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;            &lt;/ul&gt;          &lt;/template&gt;          &lt;template #s2&gt;            &lt;a href=&quot;&quot;&gt;更多&lt;/a&gt;          &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;          &lt;div class=&quot;item&quot;&gt;            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;            &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;            &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;          &lt;/div&gt;        &lt;/template&gt;\n\n3. 作用域插槽\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（新闻数据在News组件中，但使用数据所遍历出来的结构由App组件决定）\n\n具体编码：\n1234567891011121314151617181920212223242526父组件中：      &lt;Game v-slot=&quot;params&quot;&gt;      &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt;      &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;        &lt;ul&gt;          &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;      &lt;/Game&gt;子组件中：      &lt;template&gt;        &lt;div class=&quot;category&quot;&gt;          &lt;h2&gt;今日游戏榜单&lt;/h2&gt;          &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot;&gt;&lt;/slot&gt;        &lt;/div&gt;      &lt;/template&gt;      &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt;        import &#123;reactive&#125; from &#x27;vue&#x27;        let games = reactive([          &#123;id:&#x27;asgdytsa01&#x27;,name:&#x27;英雄联盟&#x27;&#125;,          &#123;id:&#x27;asgdytsa02&#x27;,name:&#x27;王者荣耀&#x27;&#125;,          &#123;id:&#x27;asgdytsa03&#x27;,name:&#x27;红色警戒&#x27;&#125;,          &#123;id:&#x27;asgdytsa04&#x27;,name:&#x27;斗罗大陆&#x27;&#125;        ])      &lt;/script&gt;\n\n7. 其它 API7.1.【shallowRef 与 shallowReactive 】shallowRef\n作用：创建一个响应式数据，但只对顶层属性进行响应式处理。\n\n用法：\n1let myVar = shallowRef(initialValue);\n\n特点：只跟踪引用值的变化，不关心值内部的属性变化。\n\n\nshallowReactive\n作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的\n\n用法：\n1const myObj = shallowReactive(&#123; ... &#125;);\n\n特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。\n\n\n总结\n\n\n\n\n\n\n\n\n通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。\n7.2.【readonly 与 shallowReadonly】readonly\n作用：用于创建一个对象的深只读副本。\n\n用法：\n12const original = reactive(&#123; ... &#125;);const readOnlyCopy = readonly(original);\n\n特点：\n\n对象的所有嵌套属性都将变为只读。\n任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。\n\n\n应用场景：\n\n创建不可变的状态快照。\n保护全局状态或配置不被修改。\n\n\n\nshallowReadonly\n作用：与 readonly 类似，但只作用于对象的顶层属性。\n\n用法：\n12const original = reactive(&#123; ... &#125;);const shallowReadOnlyCopy = shallowReadonly(original);\n\n特点：\n\n只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。\n\n适用于只需保护对象顶层属性的场景。\n\n\n\n\n7.3.【toRaw 与 markRaw】toRaw\n作用：用于获取一个响应式对象的原始对象， toRaw 返回的对象不再是响应式的，不会触发视图更新。\n\n\n\n\n\n\n\n\n\n官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。\n\n\n\n\n\n\n\n\n\n何时使用？ —— 在需要将响应式对象传递给非 Vue 的库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象\n\n具体编码：\n12345678910111213141516171819202122import &#123; reactive,toRaw,markRaw,isReactive &#125; from &quot;vue&quot;;/* toRaw */// 响应式对象let person = reactive(&#123;name:&#x27;tony&#x27;,age:18&#125;)// 原始对象let rawPerson = toRaw(person)/* markRaw */let citysd = markRaw([  &#123;id:&#x27;asdda01&#x27;,name:&#x27;北京&#x27;&#125;,  &#123;id:&#x27;asdda02&#x27;,name:&#x27;上海&#x27;&#125;,  &#123;id:&#x27;asdda03&#x27;,name:&#x27;天津&#x27;&#125;,  &#123;id:&#x27;asdda04&#x27;,name:&#x27;重庆&#x27;&#125;])// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了let citys2 = reactive(citys)console.log(isReactive(person))console.log(isReactive(rawPerson))console.log(isReactive(citys))console.log(isReactive(citys2))\n\nmarkRaw\n作用：标记一个对象，使其永远不会变成响应式的。\n\n\n\n\n\n\n\n\n\n例如使用mockjs时，为了防止误把mockjs变为响应式对象，可以使用 markRaw 去标记mockjs\n\n编码：\n123456789/* markRaw */let citys = markRaw([  &#123;id:&#x27;asdda01&#x27;,name:&#x27;北京&#x27;&#125;,  &#123;id:&#x27;asdda02&#x27;,name:&#x27;上海&#x27;&#125;,  &#123;id:&#x27;asdda03&#x27;,name:&#x27;天津&#x27;&#125;,  &#123;id:&#x27;asdda04&#x27;,name:&#x27;重庆&#x27;&#125;])// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了let citys2 = reactive(citys)\n\n7.4.【customRef】作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。\n实现防抖效果（useSumRef.ts）：\n123456789101112131415161718192021import &#123;customRef &#125; from &quot;vue&quot;;export default function(initValue:string,delay:number)&#123;  let msg = customRef((track,trigger)=&gt;&#123;    let timer:number    return &#123;      get()&#123;        track() // 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新        return initValue      &#125;,      set(value)&#123;        clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;          initValue = value          trigger() //通知Vue数据msg变化了        &#125;, delay);      &#125;    &#125;  &#125;)   return &#123;msg&#125;&#125;\n\n组件中使用：\n8. Vue3新组件8.1. 【Teleport】\n什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。\n\n1234567&lt;teleport to=&#x27;body&#x27; &gt;    &lt;div class=&quot;modal&quot; v-show=&quot;isShow&quot;&gt;      &lt;h2&gt;我是一个弹窗&lt;/h2&gt;      &lt;p&gt;我是弹窗中的一些内容&lt;/p&gt;      &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;    &lt;/div&gt;&lt;/teleport&gt;\n\n8.2. 【Suspense】\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验 \n使用步骤： \n异步引入组件\n使用Suspense包裹组件，并配置好default 与 fallback\n\n\n\n12import &#123; defineAsyncComponent,Suspense &#125; from &quot;vue&quot;;const Child = defineAsyncComponent(()=&gt;import(&#x27;./Child.vue&#x27;))\n\n12345678910111213&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;          &lt;template v-slot:default&gt;            &lt;Child/&gt;          &lt;/template&gt;          &lt;template v-slot:fallback&gt;            &lt;h3&gt;加载中.......&lt;/h3&gt;          &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;\n\n\n\n8.3.【全局API转移到应用对象】\napp.component\napp.config\napp.directive\napp.mount\napp.unmount\napp.use\n\n8.4.【其他】\n过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from。\n\nkeyCode 作为 v-on 修饰符的支持。\n\nv-model 指令在组件上的使用已经被重新设计，替换掉了 v-bind.sync。\n\nv-if 和 v-for 在同一个元素身上使用时的优先级发生了变化。\n\n移除了$on、$off 和 $once 实例方法。\n\n移除了过滤器 filter。\n\n移除了$children 实例 propert。\n……\n\n\n","slug":"vue3","date":"2024-09-05T06:23:21.000Z","categories_index":"","tags_index":"","author_index":"陈皮糖"},{"id":"f5500bc2c00e4c8bb34079231675eb79","title":"bootstarp","content":"1234567891011121314151617# Bootstrap 4.0 详情介绍Bootstrap 是一个流行的开源前端框架，用于快速构建响应式、移动优先的网站。Bootstrap 4.0 是该框架的最新版本，它引入了许多新特性和改进，使得开发更加简单和高效。本文将详细介绍 Bootstrap 4.0 的一些主要特点和功能。## 1. 响应式布局Bootstrap 4.0 提供了一套强大的响应式布局系统，可以轻松地创建适应不同屏幕尺寸的网站。通过使用栅格系统（Grid System），你可以定义网页中元素的宽度、位置和对齐方式。此外，Bootstrap 还提供了一系列的预定义类，如 `col-*`、`row` 等，以帮助你快速实现各种布局效果。```html&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;row&quot;&gt;    &lt;div class=&quot;col-sm-6 col-md-4 col-lg-3&quot;&gt;...&lt;/div&gt;    &lt;div class=&quot;col-sm-6 col-md-4 col-lg-3&quot;&gt;...&lt;/div&gt;    &lt;div class=&quot;col-sm-6 col-md-4 col-lg-3&quot;&gt;...&lt;/div&gt;    &lt;div class=&quot;col-sm-6 col-md-4 col-lg-3&quot;&gt;...&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;\n\n2. 组件库Bootstrap 4.0 包含了丰富的组件库，包括按钮、导航栏、下拉菜单、模态框、警告框、进度条等。这些组件都经过了精心设计，易于使用且具有高度可定制性。你可以通过修改 CSS 样式或添加自定义 JavaScript 代码来调整它们的外观和行为。\n12345678910111213141516171819&lt;!-- 按钮 --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;Primary&lt;/button&gt;&lt;!-- 导航栏 --&gt;&lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt;  ...&lt;/nav&gt;&lt;!-- 下拉菜单 --&gt;&lt;div class=&quot;dropdown&quot;&gt;  &lt;button class=&quot;btn btn-secondary dropdown-toggle&quot; type=&quot;button&quot; id=&quot;dropdownMenuButton&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;    Dropdown button  &lt;/button&gt;  &lt;div class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenuButton&quot;&gt;    &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Action&lt;/a&gt;    &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Another action&lt;/a&gt;    &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Something else here&lt;/a&gt;  &lt;/div&gt;&lt;/div&gt;\n\n3. 插件支持Bootstrap 4.0 支持许多第三方插件，如 jQuery、Popper.js、Font Awesome 等。这些插件可以帮助你更轻松地实现一些高级功能，如模态框、轮播图、工具提示等。此外，你还可以使用自己的 JavaScript 代码来扩展 Bootstrap 的功能。\n123456789&lt;!-- 引入 jQuery 和 Popper.js --&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.3/dist/umd/popper.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入 Bootstrap CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot;&gt;&lt;!-- 引入 Bootstrap JavaScript --&gt;&lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;\n\n4. 定制性Bootstrap 4.0 允许你根据自己的需求进行定制。你可以通过覆盖默认的 CSS 样式或添加自定义的 CSS 规则来改变组件的外观。此外，你还可以使用 Sass 变量和 mixins 来定制主题颜色、字体大小等。\n12345678910111213141516// 自定义主题颜色$theme-colors: (  primary: #007bff,  secondary: #6c757d,  success: #28a745,  danger: #dc3545,  warning: #ffc107,  info: #17a2b8,  light: #f8f9fa,  dark: #343a40);// 使用自定义主题颜色.btn-primary &#123;  background-color: map-get($theme-colors, primary);&#125;\n\n总之，Bootstrap 4.0 是一个功能强大、易于使用的前端框架，可以帮助你快速构建现代化的响应式网站。无论你是初学者还是有经验的开发者，都可以从 Bootstrap 4.0 中受益。&#96;&#96;&#96;\n","slug":"bootstarp","date":"2024-08-25T12:16:43.000Z","categories_index":"","tags_index":"bootstarp","author_index":"陈皮糖"},{"id":"e30a7113fedff4369a136e86c2843c4b","title":"uniapp","content":"UIApp 简介UIApp 是一个用于构建用户界面的应用程序框架。它提供了一套丰富的工具和组件，帮助开发者快速创建出美观、易用的界面。本文将介绍 UIApp 的基本概念、特点以及如何使用它来开发应用程序。\nUIApp 的基本概念视图（View）视图是 UIApp 中最基本的构建块，它是一个矩形区域，用于显示内容。视图可以包含其他视图，形成一个层次结构。每个视图都有一个唯一的标识符，用于在代码中引用它。\n控制器（Controller）控制器负责处理用户的输入事件，如点击按钮、滑动屏幕等。它们通常与视图关联，并在事件发生时执行相应的操作。控制器还可以更新视图的状态，以反映应用程序的数据变化。\n布局（Layout）布局决定了视图在屏幕上的位置和大小。UIApp 提供了多种布局方式，如线性布局、相对布局和网格布局等。通过组合不同的布局，开发者可以轻松地实现复杂的界面设计。\nUIApp 的特点跨平台支持UIApp 支持多种平台，包括 iOS、Android 和 Web。这意味着使用 UIApp 开发的应用程序可以在不同设备上运行，无需进行额外的适配工作。\n丰富的组件库UIApp 提供了大量的预定义组件，如按钮、文本框、滑块等。这些组件具有高度可定制性，开发者可以根据需要调整它们的外观和行为。此外，UIApp 还允许开发者自定义组件，以满足特定的需求。\n数据绑定UIApp 支持数据绑定，这意味着视图可以自动更新以反映应用程序的数据变化。这使得开发者可以更轻松地管理界面与数据的同步，减少了手动更新视图的工作量。\n高性能UIApp 采用了高效的渲染引擎，能够在短时间内呈现大量复杂的界面元素。同时，它还提供了优化性能的工具和方法，帮助开发者提高应用程序的响应速度和流畅度。\n如何使用 UIApp 开发应用程序要开始使用 UIApp 开发应用程序，首先需要安装相应的开发工具和库。然后，按照以下步骤进行操作：\n\n创建一个新的项目，并选择所需的平台和模板。\n在项目中添加视图、控制器和布局，以构建应用程序的界面。\n为视图和控制器编写代码，实现所需的功能和交互逻辑。\n使用数据绑定功能，将视图与应用程序的数据模型关联起来。\n测试应用程序，确保所有功能正常工作，并在不同的设备上进行兼容性测试。\n发布应用程序到应用商店或部署到服务器上供用户下载和使用。\n\n总之，UIApp 是一个功能强大、易于使用的应用程序框架，可以帮助开发者快速构建出高质量的用户界面。通过掌握其基本概念和特点，你可以轻松地开发出令人惊叹的应用程序。\n","slug":"uniapp","date":"2024-08-25T12:09:58.000Z","categories_index":"","tags_index":"uniapp","author_index":"陈皮糖"},{"id":"1140458028ec6e512009af2fdee3e7ce","title":"基于Hexo和GitHub Pages的静态博客方案","content":"Hexo搭建个人博客介绍Hexo是一个基于Node.js的静态博客框架，可以帮助你快速搭建一个个人博客。本文将介绍如何使用Hexo搭建个人博客。\n准备工作在开始之前，请确保你已经安装了以下软件：\n\nNode.js：访问Node.js官网下载并安装最新版本。\nGit：访问Git官网下载并安装最新版本。\n\n安装Hexo首先，打开命令行工具，执行以下命令安装Hexo：\n1npm install -g hexo-cli\n\n安装完成后，你可以使用以下命令检查Hexo是否安装成功：\n1hexo version\n\n创建博客项目接下来，我们将创建一个新的文章目录，用于存放博客的所有文件。在命令行中输入以下命令：\n12hexo init my-blogcd my-blog\n\n这将创建一个名为my-blog的新目录，并将所有Hexo相关的文件和文件夹放入其中。\n配置博客现在我们需要对博客进行一些基本的配置。打开_config.yml文件，修改以下内容：\n12345title: 我的博客subtitle: 分享技术与生活author: 你的名字language: zh-CNtimezone: Asia/Shanghai\n\n根据你的需求修改相应的信息。\n添加主题Hexo有许多精美的主题可供选择。你可以在Hexo官方主题仓库中找到你喜欢的主题。选择一个主题后，将其克隆到themes文件夹中。例如，如果你想使用hexo-theme-next主题，可以执行以下命令：\n1git clone https://github.com/next-theme/hexo-theme-next themes/next\n\n然后，打开_config.yml文件，找到theme字段并将其更改为你刚刚克隆的主题名称：\n1theme: next\n\n生成静态页面在完成上述步骤后，我们可以生成静态页面。执行以下命令：\n1hexo generate\n\n这将生成静态页面并将其保存在public文件夹中。\n本地预览要查看你的博客效果，可以在本地运行一个服务器。执行以下命令：\n1hexo server\n\n然后在浏览器中访问http://localhost:4000，你应该可以看到你的博客了。\n部署到GitHub Pages要将博客部署到GitHub Pages，你需要先创建一个GitHub仓库，并将其设置为你的博客源。然后，执行以下命令：\n1hexo deploy\n\n这将把你的博客部署到GitHub Pages上。稍等片刻，你的博客应该就可以通过https://&lt;your-username&gt;.github.io/&lt;your-repo&gt;访问了。\n至此，你已经成功使用Hexo搭建了一个个人博客。你可以开始撰写文章、发布博客并与他人分享你的想法和技术了。祝你写作愉快！&#96;&#96;&#96;\n","slug":"hexo","date":"2024-07-25T12:09:58.000Z","categories_index":"","tags_index":"hexo","author_index":"陈皮糖"}]